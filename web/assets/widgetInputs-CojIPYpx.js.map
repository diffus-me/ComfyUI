{"version":3,"file":"widgetInputs-CojIPYpx.js","sources":["../../src/extensions/core/widgetInputs.ts"],"sourcesContent":["// @ts-strict-ignore\nimport { ComfyWidgets, addValueControlWidgets } from '../../scripts/widgets'\nimport { app } from '../../scripts/app'\nimport { applyTextReplacements } from '../../scripts/utils'\nimport { LiteGraph, LGraphNode } from '@comfyorg/litegraph'\nimport type { INodeInputSlot, IWidget } from '@comfyorg/litegraph'\nimport type { InputSpec } from '@/types/apiTypes'\n\nconst CONVERTED_TYPE = 'converted-widget'\nconst VALID_TYPES = [\n  'STRING',\n  'combo',\n  'number',\n  'toggle',\n  'BOOLEAN',\n  'text',\n  'string'\n]\nconst CONFIG = Symbol()\nconst GET_CONFIG = Symbol()\nconst TARGET = Symbol() // Used for reroutes to specify the real target widget\n\ninterface PrimitiveNode extends LGraphNode {}\n\nconst replacePropertyName = 'Run widget replace on values'\nclass PrimitiveNode extends LGraphNode {\n  controlValues: any[]\n  lastType: string\n  static category: string\n  constructor(title?: string) {\n    super(title)\n    this.addOutput('connect to widget input', '*')\n    this.serialize_widgets = true\n    this.isVirtualNode = true\n\n    if (!this.properties || !(replacePropertyName in this.properties)) {\n      this.addProperty(replacePropertyName, false, 'boolean')\n    }\n  }\n\n  applyToGraph(extraLinks = []) {\n    if (!this.outputs[0].links?.length) return\n\n    function get_links(node) {\n      let links = []\n      for (const l of node.outputs[0].links) {\n        const linkInfo = app.graph.links[l]\n        const n = node.graph.getNodeById(linkInfo.target_id)\n        if (n.type == 'Reroute') {\n          links = links.concat(get_links(n))\n        } else {\n          links.push(l)\n        }\n      }\n      return links\n    }\n\n    let links = [\n      ...get_links(this).map((l) => app.graph.links[l]),\n      ...extraLinks\n    ]\n    let v = this.widgets?.[0].value\n    if (v && this.properties[replacePropertyName]) {\n      v = applyTextReplacements(app, v as string)\n    }\n\n    // For each output link copy our value over the original widget value\n    for (const linkInfo of links) {\n      const node = this.graph.getNodeById(linkInfo.target_id)\n      const input = node.inputs[linkInfo.target_slot]\n      let widget\n      if (input.widget[TARGET]) {\n        widget = input.widget[TARGET]\n      } else {\n        const widgetName = (input.widget as { name: string }).name\n        if (widgetName) {\n          widget = node.widgets.find((w) => w.name === widgetName)\n        }\n      }\n\n      if (widget) {\n        widget.value = v\n        if (widget.callback) {\n          widget.callback(\n            widget.value,\n            app.canvas,\n            node,\n            app.canvas.graph_mouse,\n            {}\n          )\n        }\n      }\n    }\n  }\n\n  refreshComboInNode() {\n    const widget = this.widgets?.[0]\n    if (widget?.type === 'combo') {\n      widget.options.values = this.outputs[0].widget[GET_CONFIG]()[0]\n\n      if (!widget.options.values.includes(widget.value as string)) {\n        widget.value = widget.options.values[0]\n        ;(widget.callback as Function)(widget.value)\n      }\n    }\n  }\n\n  onAfterGraphConfigured() {\n    if (this.outputs[0].links?.length && !this.widgets?.length) {\n      // TODO: Review this check\n      // @ts-expect-error\n      if (!this.#onFirstConnection()) return\n\n      // Populate widget values from config data\n      if (this.widgets) {\n        for (let i = 0; i < this.widgets_values.length; i++) {\n          const w = this.widgets[i]\n          if (w) {\n            // @ts-expect-error change widget type from string to unknown\n            w.value = this.widgets_values[i]\n          }\n        }\n      }\n\n      // Merge values if required\n      this.#mergeWidgetConfig()\n    }\n  }\n\n  onConnectionsChange(_, index, connected) {\n    if (app.configuringGraph) {\n      // Dont run while the graph is still setting up\n      return\n    }\n\n    const links = this.outputs[0].links\n    if (connected) {\n      if (links?.length && !this.widgets?.length) {\n        this.#onFirstConnection()\n      }\n    } else {\n      // We may have removed a link that caused the constraints to change\n      this.#mergeWidgetConfig()\n\n      if (!links?.length) {\n        this.onLastDisconnect()\n      }\n    }\n  }\n\n  onConnectOutput(slot, type, input, target_node, target_slot) {\n    // Fires before the link is made allowing us to reject it if it isn't valid\n    // No widget, we cant connect\n    if (!input.widget) {\n      if (!(input.type in ComfyWidgets)) return false\n    }\n\n    if (this.outputs[slot].links?.length) {\n      const valid = this.#isValidConnection(input)\n      if (valid) {\n        // On connect of additional outputs, copy our value to their widget\n        this.applyToGraph([{ target_id: target_node.id, target_slot }])\n      }\n      return valid\n    }\n  }\n\n  #onFirstConnection(recreating?: boolean) {\n    // First connection can fire before the graph is ready on initial load so random things can be missing\n    if (!this.outputs[0].links) {\n      this.onLastDisconnect()\n      return\n    }\n    const linkId = this.outputs[0].links[0]\n    const link = this.graph.links[linkId]\n    if (!link) return\n\n    const theirNode = this.graph.getNodeById(link.target_id)\n    if (!theirNode || !theirNode.inputs) return\n\n    const input = theirNode.inputs[link.target_slot]\n    if (!input) return\n\n    let widget\n    if (!input.widget) {\n      if (!(input.type in ComfyWidgets)) return\n      widget = { name: input.name, [GET_CONFIG]: () => [input.type, {}] } //fake widget\n    } else {\n      widget = input.widget\n    }\n\n    const config = widget[GET_CONFIG]?.()\n    if (!config) return\n\n    const { type } = getWidgetType(config)\n    // Update our output to restrict to the widget type\n    this.outputs[0].type = type\n    this.outputs[0].name = type\n    this.outputs[0].widget = widget\n\n    this.#createWidget(\n      widget[CONFIG] ?? config,\n      theirNode,\n      widget.name,\n      recreating,\n      widget[TARGET]\n    )\n  }\n\n  #createWidget(inputData, node, widgetName, recreating, targetWidget) {\n    let type = inputData[0]\n\n    if (type instanceof Array) {\n      type = 'COMBO'\n    }\n\n    // Store current size as addWidget resizes the node\n    const size = this.size\n    let widget\n    if (type in ComfyWidgets) {\n      widget = (ComfyWidgets[type](this, 'value', inputData, app) || {}).widget\n    } else {\n      widget = this.addWidget(type, 'value', null, () => {}, {})\n    }\n\n    if (targetWidget) {\n      widget.value = targetWidget.value\n    } else if (node?.widgets && widget) {\n      const theirWidget = node.widgets.find((w) => w.name === widgetName)\n      if (theirWidget) {\n        widget.value = theirWidget.value\n      }\n    }\n\n    if (\n      !inputData?.[1]?.control_after_generate &&\n      (widget.type === 'number' || widget.type === 'combo')\n    ) {\n      let control_value = this.widgets_values?.[1]\n      if (!control_value) {\n        control_value = 'fixed'\n      }\n      addValueControlWidgets(\n        this,\n        widget,\n        control_value as string,\n        undefined,\n        inputData\n      )\n      let filter = this.widgets_values?.[2]\n      if (filter && this.widgets.length === 3) {\n        // @ts-expect-error change widget type from string to unknown\n        this.widgets[2].value = filter\n      }\n    }\n\n    // Restore any saved control values\n    const controlValues = this.controlValues\n    if (\n      this.lastType === this.widgets[0].type &&\n      controlValues?.length === this.widgets.length - 1\n    ) {\n      for (let i = 0; i < controlValues.length; i++) {\n        this.widgets[i + 1].value = controlValues[i]\n      }\n    }\n\n    // When our value changes, update other widgets to reflect our changes\n    // e.g. so LoadImage shows correct image\n    const callback = widget.callback\n    const self = this\n    widget.callback = function () {\n      const r = callback ? callback.apply(this, arguments) : undefined\n      self.applyToGraph()\n      return r\n    }\n\n    // Use the biggest dimensions in case the widgets caused the node to grow\n    this.size = [\n      Math.max(this.size[0], size[0]),\n      Math.max(this.size[1], size[1])\n    ]\n\n    if (!recreating) {\n      // Grow our node more if required\n      const sz = this.computeSize()\n      if (this.size[0] < sz[0]) {\n        this.size[0] = sz[0]\n      }\n      if (this.size[1] < sz[1]) {\n        this.size[1] = sz[1]\n      }\n\n      requestAnimationFrame(() => {\n        if (this.onResize) {\n          this.onResize(this.size)\n        }\n      })\n    }\n  }\n\n  recreateWidget() {\n    const values = this.widgets?.map((w) => w.value)\n    this.#removeWidgets()\n    this.#onFirstConnection(true)\n    if (values?.length) {\n      for (let i = 0; i < this.widgets?.length; i++)\n        this.widgets[i].value = values[i]\n    }\n    return this.widgets?.[0]\n  }\n\n  #mergeWidgetConfig() {\n    // Merge widget configs if the node has multiple outputs\n    const output = this.outputs[0]\n    const links = output.links\n\n    const hasConfig = !!output.widget[CONFIG]\n    if (hasConfig) {\n      delete output.widget[CONFIG]\n    }\n\n    if (links?.length < 2 && hasConfig) {\n      // Copy the widget options from the source\n      if (links.length) {\n        this.recreateWidget()\n      }\n\n      return\n    }\n\n    const config1 = output.widget[GET_CONFIG]()\n    const isNumber = config1[0] === 'INT' || config1[0] === 'FLOAT'\n    if (!isNumber) return\n\n    for (const linkId of links) {\n      const link = app.graph.links[linkId]\n      if (!link) continue // Can be null when removing a node\n\n      const theirNode = app.graph.getNodeById(link.target_id)\n      const theirInput = theirNode.inputs[link.target_slot]\n\n      // Call is valid connection so it can merge the configs when validating\n      this.#isValidConnection(theirInput, hasConfig)\n    }\n  }\n\n  isValidWidgetLink(\n    originSlot: number,\n    targetNode: LGraphNode,\n    targetWidget: IWidget\n  ) {\n    const config2 = getConfig.call(targetNode, targetWidget.name) ?? [\n      targetWidget.type,\n      targetWidget.options || {}\n    ]\n    if (!isConvertibleWidget(targetWidget, config2)) return false\n\n    const output = this.outputs[originSlot]\n    if (!(output.widget?.[CONFIG] ?? output.widget?.[GET_CONFIG]())) {\n      // No widget defined for this primitive yet so allow it\n      return true\n    }\n\n    return !!mergeIfValid.call(this, output, config2)\n  }\n\n  #isValidConnection(input: INodeInputSlot, forceUpdate?: boolean) {\n    // Only allow connections where the configs match\n    const output = this.outputs[0]\n    const config2 = input.widget[GET_CONFIG]()\n    return !!mergeIfValid.call(\n      this,\n      output,\n      config2,\n      forceUpdate,\n      this.recreateWidget\n    )\n  }\n\n  #removeWidgets() {\n    if (this.widgets) {\n      // Allow widgets to cleanup\n      for (const w of this.widgets) {\n        if (w.onRemove) {\n          w.onRemove()\n        }\n      }\n\n      // Temporarily store the current values in case the node is being recreated\n      // e.g. by group node conversion\n      this.controlValues = []\n      this.lastType = this.widgets[0]?.type\n      for (let i = 1; i < this.widgets.length; i++) {\n        this.controlValues.push(this.widgets[i].value)\n      }\n      setTimeout(() => {\n        delete this.lastType\n        delete this.controlValues\n      }, 15)\n      this.widgets.length = 0\n    }\n  }\n\n  onLastDisconnect() {\n    // We cant remove + re-add the output here as if you drag a link over the same link\n    // it removes, then re-adds, causing it to break\n    this.outputs[0].type = '*'\n    this.outputs[0].name = 'connect to widget input'\n    delete this.outputs[0].widget\n\n    this.#removeWidgets()\n  }\n}\n\nexport function getWidgetConfig(slot) {\n  return slot.widget[CONFIG] ?? slot.widget[GET_CONFIG]()\n}\n\nfunction getConfig(widgetName) {\n  const { nodeData } = this.constructor\n  return (\n    nodeData?.input?.required?.[widgetName] ??\n    nodeData?.input?.optional?.[widgetName]\n  )\n}\n\nfunction isConvertibleWidget(widget, config) {\n  return (\n    (VALID_TYPES.includes(widget.type) || VALID_TYPES.includes(config[0])) &&\n    !widget.options?.forceInput\n  )\n}\n\nfunction hideWidget(node, widget, suffix = '') {\n  if (widget.type?.startsWith(CONVERTED_TYPE)) return\n  widget.origType = widget.type\n  widget.origComputeSize = widget.computeSize\n  widget.origSerializeValue = widget.serializeValue\n  widget.computeSize = () => [0, -4] // -4 is due to the gap litegraph adds between widgets automatically\n  widget.type = CONVERTED_TYPE + suffix\n  widget.serializeValue = () => {\n    // Prevent serializing the widget if we have no input linked\n    if (!node.inputs) {\n      return undefined\n    }\n    let node_input = node.inputs.find((i) => i.widget?.name === widget.name)\n\n    if (!node_input || !node_input.link) {\n      return undefined\n    }\n    return widget.origSerializeValue\n      ? widget.origSerializeValue()\n      : widget.value\n  }\n\n  // Hide any linked widgets, e.g. seed+seedControl\n  if (widget.linkedWidgets) {\n    for (const w of widget.linkedWidgets) {\n      hideWidget(node, w, ':' + widget.name)\n    }\n  }\n}\n\nfunction showWidget(widget) {\n  widget.type = widget.origType\n  widget.computeSize = widget.origComputeSize\n  widget.serializeValue = widget.origSerializeValue\n\n  delete widget.origType\n  delete widget.origComputeSize\n  delete widget.origSerializeValue\n\n  // Hide any linked widgets, e.g. seed+seedControl\n  if (widget.linkedWidgets) {\n    for (const w of widget.linkedWidgets) {\n      showWidget(w)\n    }\n  }\n}\n\nexport function convertToInput(\n  node: LGraphNode,\n  widget: IWidget,\n  config: InputSpec\n) {\n  hideWidget(node, widget)\n\n  const { type } = getWidgetType(config)\n\n  // Add input and store widget config for creating on primitive node\n  const sz = node.size\n  const inputIsOptional = !!widget.options?.inputIsOptional\n  const input = node.addInput(widget.name, type, {\n    widget: { name: widget.name, [GET_CONFIG]: () => config },\n    ...(inputIsOptional ? { shape: LiteGraph.SlotShape.HollowCircle } : {})\n  })\n\n  for (const widget of node.widgets) {\n    widget.last_y += LiteGraph.NODE_SLOT_HEIGHT\n  }\n\n  // Restore original size but grow if needed\n  node.setSize([Math.max(sz[0], node.size[0]), Math.max(sz[1], node.size[1])])\n  return input\n}\n\nfunction convertToWidget(node, widget) {\n  showWidget(widget)\n  const sz = node.size\n  node.removeInput(node.inputs.findIndex((i) => i.widget?.name === widget.name))\n\n  for (const widget of node.widgets) {\n    widget.last_y -= LiteGraph.NODE_SLOT_HEIGHT\n  }\n\n  // Restore original size but grow if needed\n  node.setSize([Math.max(sz[0], node.size[0]), Math.max(sz[1], node.size[1])])\n}\n\nfunction getWidgetType(config: InputSpec) {\n  // Special handling for COMBO so we restrict links based on the entries\n  let type = config[0]\n  if (type instanceof Array) {\n    type = 'COMBO'\n  }\n  return { type }\n}\n\nfunction isValidCombo(combo, obj) {\n  // New input isnt a combo\n  if (!(obj instanceof Array)) {\n    console.log(`connection rejected: tried to connect combo to ${obj}`)\n    return false\n  }\n  // New input combo has a different size\n  if (combo.length !== obj.length) {\n    console.log(`connection rejected: combo lists dont match`)\n    return false\n  }\n  // New input combo has different elements\n  if (combo.find((v, i) => obj[i] !== v)) {\n    console.log(`connection rejected: combo lists dont match`)\n    return false\n  }\n\n  return true\n}\n\nfunction isPrimitiveNode(node: LGraphNode): node is PrimitiveNode {\n  return node.type === 'PrimitiveNode'\n}\n\nexport function setWidgetConfig(slot, config, target?: IWidget) {\n  if (!slot.widget) return\n  if (config) {\n    slot.widget[GET_CONFIG] = () => config\n    slot.widget[TARGET] = target\n  } else {\n    delete slot.widget\n  }\n\n  if (slot.link) {\n    const link = app.graph.links[slot.link]\n    if (link) {\n      const originNode = app.graph.getNodeById(link.origin_id)\n      if (isPrimitiveNode(originNode)) {\n        if (config) {\n          originNode.recreateWidget()\n        } else if (!app.configuringGraph) {\n          originNode.disconnectOutput(0)\n          originNode.onLastDisconnect()\n        }\n      }\n    }\n  }\n}\n\nexport function mergeIfValid(\n  output,\n  config2,\n  forceUpdate?: boolean,\n  recreateWidget?: () => void,\n  config1?: unknown\n) {\n  if (!config1) {\n    config1 = output.widget[CONFIG] ?? output.widget[GET_CONFIG]()\n  }\n\n  if (config1[0] instanceof Array) {\n    if (!isValidCombo(config1[0], config2[0])) return\n  } else if (config1[0] !== config2[0]) {\n    // Types dont match\n    console.log(`connection rejected: types dont match`, config1[0], config2[0])\n    return\n  }\n\n  const keys = new Set([\n    ...Object.keys(config1[1] ?? {}),\n    ...Object.keys(config2[1] ?? {})\n  ])\n\n  let customConfig\n  const getCustomConfig = () => {\n    if (!customConfig) {\n      if (typeof structuredClone === 'undefined') {\n        customConfig = JSON.parse(JSON.stringify(config1[1] ?? {}))\n      } else {\n        customConfig = structuredClone(config1[1] ?? {})\n      }\n    }\n    return customConfig\n  }\n\n  const isNumber = config1[0] === 'INT' || config1[0] === 'FLOAT'\n  for (const k of keys.values()) {\n    if (\n      k !== 'default' &&\n      k !== 'forceInput' &&\n      k !== 'defaultInput' &&\n      k !== 'control_after_generate' &&\n      k !== 'multiline' &&\n      k !== 'tooltip'\n    ) {\n      let v1 = config1[1][k]\n      let v2 = config2[1]?.[k]\n\n      if (v1 === v2 || (!v1 && !v2)) continue\n\n      if (isNumber) {\n        if (k === 'min') {\n          const theirMax = config2[1]?.['max']\n          if (theirMax != null && v1 > theirMax) {\n            console.log('connection rejected: min > max', v1, theirMax)\n            return\n          }\n          getCustomConfig()[k] =\n            v1 == null ? v2 : v2 == null ? v1 : Math.max(v1, v2)\n          continue\n        } else if (k === 'max') {\n          const theirMin = config2[1]?.['min']\n          if (theirMin != null && v1 < theirMin) {\n            console.log('connection rejected: max < min', v1, theirMin)\n            return\n          }\n          getCustomConfig()[k] =\n            v1 == null ? v2 : v2 == null ? v1 : Math.min(v1, v2)\n          continue\n        } else if (k === 'step') {\n          let step\n          if (v1 == null) {\n            // No current step\n            step = v2\n          } else if (v2 == null) {\n            // No new step\n            step = v1\n          } else {\n            if (v1 < v2) {\n              // Ensure v1 is larger for the mod\n              const a = v2\n              v2 = v1\n              v1 = a\n            }\n            if (v1 % v2) {\n              console.log(\n                'connection rejected: steps not divisible',\n                'current:',\n                v1,\n                'new:',\n                v2\n              )\n              return\n            }\n\n            step = v1\n          }\n\n          getCustomConfig()[k] = step\n          continue\n        }\n      }\n\n      console.log(`connection rejected: config ${k} values dont match`, v1, v2)\n      return\n    }\n  }\n\n  if (customConfig || forceUpdate) {\n    if (customConfig) {\n      output.widget[CONFIG] = [config1[0], customConfig]\n    }\n\n    const widget = recreateWidget?.call(this)\n    // When deleting a node this can be null\n    if (widget) {\n      const min = widget.options.min\n      const max = widget.options.max\n      if (min != null && widget.value < min) widget.value = min\n      if (max != null && widget.value > max) widget.value = max\n      widget.callback(widget.value)\n    }\n  }\n\n  return { customConfig }\n}\n\nlet useConversionSubmenusSetting\napp.registerExtension({\n  name: 'Comfy.WidgetInputs',\n  init() {\n    useConversionSubmenusSetting = app.ui.settings.addSetting({\n      id: 'Comfy.NodeInputConversionSubmenus',\n      name: 'In the node context menu, place the entries that convert between input/widget in sub-menus.',\n      type: 'boolean',\n      defaultValue: true\n    })\n  },\n  async beforeRegisterNodeDef(nodeType, nodeData, app) {\n    // Add menu options to convert to/from widgets\n    const origGetExtraMenuOptions = nodeType.prototype.getExtraMenuOptions\n    nodeType.prototype.convertWidgetToInput = function (widget) {\n      const config = getConfig.call(this, widget.name) ?? [\n        widget.type,\n        widget.options || {}\n      ]\n      if (!isConvertibleWidget(widget, config)) return false\n      if (widget.type?.startsWith(CONVERTED_TYPE)) return false\n      convertToInput(this, widget, config)\n      return true\n    }\n    nodeType.prototype.getExtraMenuOptions = function (_, options) {\n      const r = origGetExtraMenuOptions\n        ? origGetExtraMenuOptions.apply(this, arguments)\n        : undefined\n\n      if (this.widgets) {\n        let toInput = []\n        let toWidget = []\n        for (const w of this.widgets) {\n          if (w.options?.forceInput) {\n            continue\n          }\n          if (w.type === CONVERTED_TYPE) {\n            toWidget.push({\n              content: `Convert ${w.name} to widget`,\n              callback: () => convertToWidget(this, w)\n            })\n          } else {\n            const config = getConfig.call(this, w.name) ?? [\n              w.type,\n              w.options || {}\n            ]\n            if (isConvertibleWidget(w, config)) {\n              toInput.push({\n                content: `Convert ${w.name} to input`,\n                callback: () => convertToInput(this, w, config)\n              })\n            }\n          }\n        }\n\n        //Convert.. main menu\n        if (toInput.length) {\n          if (useConversionSubmenusSetting.value) {\n            options.push({\n              content: 'Convert Widget to Input',\n              submenu: {\n                options: toInput\n              }\n            })\n          } else {\n            options.push(...toInput, null)\n          }\n        }\n        if (toWidget.length) {\n          if (useConversionSubmenusSetting.value) {\n            options.push({\n              content: 'Convert Input to Widget',\n              submenu: {\n                options: toWidget\n              }\n            })\n          } else {\n            options.push(...toWidget, null)\n          }\n        }\n      }\n\n      return r\n    }\n\n    nodeType.prototype.onGraphConfigured = function () {\n      if (!this.inputs) return\n      this.widgets ??= []\n\n      for (const input of this.inputs) {\n        if (input.widget) {\n          if (!input.widget[GET_CONFIG]) {\n            input.widget[GET_CONFIG] = () =>\n              getConfig.call(this, input.widget.name)\n          }\n\n          // Cleanup old widget config\n          if (input.widget.config) {\n            if (input.widget.config[0] instanceof Array) {\n              // If we are an old converted combo then replace the input type and the stored link data\n              input.type = 'COMBO'\n\n              const link = app.graph.links[input.link]\n              if (link) {\n                link.type = input.type\n              }\n            }\n            delete input.widget.config\n          }\n\n          const w = this.widgets.find((w) => w.name === input.widget.name)\n          if (w) {\n            hideWidget(this, w)\n          } else {\n            convertToWidget(this, input)\n          }\n        }\n      }\n    }\n\n    const origOnNodeCreated = nodeType.prototype.onNodeCreated\n    nodeType.prototype.onNodeCreated = function () {\n      const r = origOnNodeCreated ? origOnNodeCreated.apply(this) : undefined\n\n      // When node is created, convert any force/default inputs\n      if (!app.configuringGraph && this.widgets) {\n        for (const w of this.widgets) {\n          if (w?.options?.forceInput || w?.options?.defaultInput) {\n            const config = getConfig.call(this, w.name) ?? [\n              w.type,\n              w.options || {}\n            ]\n            convertToInput(this, w, config)\n          }\n        }\n      }\n\n      return r\n    }\n\n    const origOnConfigure = nodeType.prototype.onConfigure\n    nodeType.prototype.onConfigure = function () {\n      const r = origOnConfigure\n        ? origOnConfigure.apply(this, arguments)\n        : undefined\n      if (!app.configuringGraph && this.inputs) {\n        // On copy + paste of nodes, ensure that widget configs are set up\n        for (const input of this.inputs) {\n          if (input.widget && !input.widget[GET_CONFIG]) {\n            input.widget[GET_CONFIG] = () =>\n              getConfig.call(this, input.widget.name)\n            const w = this.widgets.find((w) => w.name === input.widget.name)\n            if (w) {\n              hideWidget(this, w)\n            }\n          }\n        }\n      }\n\n      return r\n    }\n\n    function isNodeAtPos(pos) {\n      for (const n of app.graph.nodes) {\n        if (n.pos[0] === pos[0] && n.pos[1] === pos[1]) {\n          return true\n        }\n      }\n      return false\n    }\n\n    // Double click a widget input to automatically attach a primitive\n    const origOnInputDblClick = nodeType.prototype.onInputDblClick\n    const ignoreDblClick = Symbol()\n    nodeType.prototype.onInputDblClick = function (slot) {\n      const r = origOnInputDblClick\n        ? origOnInputDblClick.apply(this, arguments)\n        : undefined\n\n      const input = this.inputs[slot]\n      if (!input.widget || !input[ignoreDblClick]) {\n        // Not a widget input or already handled input\n        if (\n          !(input.type in ComfyWidgets) &&\n          !(input.widget[GET_CONFIG]?.()?.[0] instanceof Array)\n        ) {\n          return r //also Not a ComfyWidgets input or combo (do nothing)\n        }\n      }\n\n      // Create a primitive node\n      const node = LiteGraph.createNode('PrimitiveNode')\n      app.graph.add(node)\n\n      // Calculate a position that wont directly overlap another node\n      const pos: [number, number] = [\n        this.pos[0] - node.size[0] - 30,\n        this.pos[1]\n      ]\n      while (isNodeAtPos(pos)) {\n        pos[1] += LiteGraph.NODE_TITLE_HEIGHT\n      }\n\n      node.pos = pos\n      node.connect(0, this, slot)\n      node.title = input.name\n\n      // Prevent adding duplicates due to triple clicking\n      input[ignoreDblClick] = true\n      setTimeout(() => {\n        delete input[ignoreDblClick]\n      }, 300)\n\n      return r\n    }\n\n    // Prevent connecting COMBO lists to converted inputs that dont match types\n    const onConnectInput = nodeType.prototype.onConnectInput\n    nodeType.prototype.onConnectInput = function (\n      targetSlot,\n      type,\n      output,\n      originNode,\n      originSlot\n    ) {\n      const v = onConnectInput?.(this, arguments)\n      // Not a combo, ignore\n      if (type !== 'COMBO') return v\n      // Primitive output, allow that to handle\n      if (originNode.outputs[originSlot].widget) return v\n\n      // Ensure target is also a combo\n      const targetCombo = this.inputs[targetSlot].widget?.[GET_CONFIG]?.()?.[0]\n      if (!targetCombo || !(targetCombo instanceof Array)) return v\n\n      // Check they match\n      const originConfig =\n        originNode.constructor?.nodeData?.output?.[originSlot]\n      if (!originConfig || !isValidCombo(targetCombo, originConfig)) {\n        return false\n      }\n\n      return v\n    }\n  },\n  registerCustomNodes() {\n    LiteGraph.registerNodeType(\n      'PrimitiveNode',\n      Object.assign(PrimitiveNode, {\n        title: 'Primitive'\n      })\n    )\n    PrimitiveNode.category = 'utils'\n  }\n})\n"],"names":["links","widget","app","w"],"mappings":"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"}